#!/bin/bash
# Git pre-commit hook to ensure all files have exactly one newline at the end

# Colors for output
BOLD="\033[1m"
NORMAL="\033[0m"
GREEN="\033[32m"
YELLOW="\033[33m"
RED="\033[31m"
BLUE="\033[34m"

echo -e "${BLUE}${BOLD}Running pre-commit hook: Ensuring files end with newline${NORMAL}"

# Get the root directory of the repository
REPO_ROOT=$(git rev-parse --show-toplevel)

# Get list of all staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo -e "${YELLOW}No files staged for commit.${NORMAL}"
    exit 0
fi

# Flag to track if we made any changes
FIXED_FILES=0

# Process each staged file
for FILE in $STAGED_FILES; do
    # Skip binary files, symlinks, and files that don't exist
    if [ ! -f "$REPO_ROOT/$FILE" ] || [ -L "$REPO_ROOT/$FILE" ]; then
        continue
    fi

    # Check if file is binary
    if file "$REPO_ROOT/$FILE" | grep -q "binary"; then
        continue
    fi
    
    # Create a temporary file
    TMP_FILE=$(mktemp)
    
    # Fix the file content to have exactly one newline at the end
    # Use perl which has better handling for newlines
    perl -0777 -pe 's/\n*\z/\n/' "$REPO_ROOT/$FILE" > "$TMP_FILE"
    
    # Check if the file was modified
    if ! cmp -s "$TMP_FILE" "$REPO_ROOT/$FILE"; then
        # File was modified, copy it back and stage it
        cp "$TMP_FILE" "$REPO_ROOT/$FILE"
        echo -e "${YELLOW}Fixing newlines in: ${BOLD}$FILE${NORMAL}"
        FIXED_FILES=$((FIXED_FILES+1))
        
        # Stage the fixed file
        git add "$REPO_ROOT/$FILE"
    fi
    
    # Clean up the temporary file
    rm "$TMP_FILE"
done

if [ $FIXED_FILES -gt 0 ]; then
    echo -e "${GREEN}Fixed newline at end of file for ${BOLD}$FIXED_FILES${NORMAL}${GREEN} file(s).${NORMAL}"
else
    echo -e "${GREEN}All files already have proper newline endings.${NORMAL}"
fi

# Always exit with success - we've fixed any issues automatically
exit 0
